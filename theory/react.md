link yourube :https://www.youtube.com/watch?v=5it_Uv7pGFg&ab_channel=SangamMukherjee
1:36 = What is react js?

2:18 = What are the major features of react?

4:29 = What is virtual DOM and how it works?

6:00 = What are the components in react?

-> 6:54 = Explain Class components with example.

-> 8:15 = Explain Functional components with example.

9:58 = What is JSX?

12:04 = How to export and import components?

13:20 = How to use nested components?

15:02 = What is state in react?

-> 17:20 = Example

19:33 = How to update state in react?

22:26 = What is setState callback?

23:56 = Why you should not update state directly, explain with example?

25:10 = What are props in react?

27:05 = What is difference between state and props?

28:48 = What is lifting state up in react?

32:02 = What is children prop in react?

33:26 = What is defaultProps in react?

34:58 = What are fragments in react and its advantages?

36:07 = How to use styling in react js?

40:30 = How can you conditionally render components in react?

42:29 = How to render list of data in react?

44:08 = What is key prop?

45:24 = Why indexes for keys are not recommended?

48:00 = How to handle buttons in react? 

49:25 = How to handle inputs in react?

51:36 = Explain lifecycle methods in react.

54:13 = What are the popular hooks in react and explain it's usage?

56:22 = What is useState and how to manage state using it?

58:52 = What is useEffect hook and how to manage side effects?

1:00:41 = How to implement data fetching in reactjs?

-> 1:02:44 = How to manage loading state?

1:04:04 = What is prop drilling and how to avoid it? (OR) What is Context API and why we need Context API?

1:06:22 = What is the Context API in react and why is it used?

1:08:45 = How do you consume context using the useContext hook?

1:10:10 = How can you update context values?

1:11:54 = How do you use multiple Contexts in a single component?

1:13:14 = What are the advantages of using the Context API over prop drilling?

1:14:39 = What is the useReducer hook, and when should you use it?

'useReducer' is basically an alternative of 'useState'. 'useState' basicall
y used for state management.

'dispatch' will dispatch a method. It has 'type' property.

1:18:32 = Can you use useReducer with complex state objects?

1:19:35 = How do you pass additional arguments to the reducer function?

// Intermediate level of interviews

1:21:07 = How do you handle side effects with useReducer?

1:22:55 = What is useRef hook?

1:25:07 = How can useRef be used to store mutable values?

1:26:07 = What is forwardRef and when would you use it?

1:28:24 = How to manage forms in react?

1:31:27 = What are Custom Hooks and Why do we need them?

1:33:37 = Implement useFetch custom hook/ Custom hook example?

// Intermediate level of interviews

1:35:41 = Implement useWindowResize custom hook

1:37:33 = What is React Router DOM and why is it used?

1:38:32 = How do you create a basic route in React Router DOM?

1:39:35 = How to implement basic routing using react router dom?

1:41:59 = How to create a link to another route using React Router DOM?

1:43:09 = How do you use URL parameters / Dynamic routing in React Router DOM?

1:45:27 = How can you perform a redirect in React Router DOM?

1:46:31 = What is a Routes component in React Router DOM?

1:47:29 = How do you handle nested routes in React Router DOM?

1:49:40 = How can you handle 404 errors(not found) in React Rou
ter DOM?

1:50:35 = How do you programmatically navigate using React Router DOM?

1:52:09 = Explain useCallback hook with example

1:54:21 = Explain useMemo hook with example

1:56:52 = Explain React.memo with example

1:58:15 = Explain the reconciliation process in React and how it works.

1:59:33 = What are Pure components?

2:00:40 = Explain higher order component with example.

2:02:11 = What is redux, explain core principles.

2:03:24 = What are actions in Redux, explain with example?

2:04:34 = Explain reducers in Redux with an example.

2:05:25 = What is the role of the Redux store?

2:06:42 = How do you connect React components to Redux store using connect?

2:08:30 = How do you use the useSelector and useDispatch hooks in a function React component?

2:10:09 = What is Redux Toolkit?

2:10:41 = How to configure store in redux toolkit?

2:12:00 = Explain createSlice in Redux Toolkit with an example.

2:13:37 = What are controlled components in React?

2:14:31 = What are uncontrolled components in React?

2:15:28 = How do you optimize performance in React applications?

2:16:22 = What is code splitting in React?

2:17:50 = What are render props in React? Give an example

2:18:39 = What are portals in React?

2:20:05 = How do you implement lazy loading in React?

2:20:45 = How do you define props for a functional component in TypeScript?

2:21:41 = How do you use the useState hook with TypeScript?

2:22:18 = How do you type event handlers in React with TypeScript?

2:23:19 = How do you handle optional props in React components with TypeScript?

2:24:02 = How do you use the useReducer hook with TypeScript?

2:25:10 = How do you type the context API in React with TypeScript?

2:26:06 = How do you write a simple test in Jest

2:27:44 = How do you render a component for testing using React Testing Library

2:28:27 = How can you find elements in the DOM using React Testing Library?

2:29:51 = How do you simulate user events in React Testing Library?

2:31:05 = How can you test component props with React Testing Library?

// Hands-on Questions
2:31:53 = Create a Controlled Input Component

2:32:42 = Implement toggle Visibility of a Component

2:33:20 = Fetch Data from an API and Display it, along with loading state.

2:33:52 = Create a Reusable Button Component with Props

2:35:05 = Build a Component that Uses an Effect to Perform Cleanup

2:35:48 = Implement a Context with a Reducer for Global State Management

2:36:11 = Build a Component with Conditional Rendering Based on Props

2:37:17 = Implement a simple form component









* What is UST Hook :> Pointers*
- 58:52 :> useEffect
- 
-- 1:00:42 :> dataFetching example
  
-- 1:03:44 :> managing loading state

-- 1:04:04 >  concept prop drilling

----------------------------------------------------------------------------------
-- 1:06:21 :> ContextAPI > solution to prop drilling

-- 1:08:45 :> Context API > useContext

-- 1:10:10 :> Context API > updating context values

-- 1:11:53 :> Context API > Multiple context

-- 1:13:13 :> Context API advantages over prop drilling

----------------------------------------------------------------------------------
- 1:14:38 :> useReducer
- 
-- 1:18:32 :> useReducer : Complex example
  
-- 1:19:34 :> useReducer : additional argument {type:"type", payload:{}}

-- 1:21:06 :> useReducer : handle sideEffect

----------------------------------------------------------------------------------
- 1:22:55 :> useRef
- 
-- 1:25:05 :> useRef > store mutable
  
-- 1:26:06 :> forwardRef

- 1:28:23 :> Forms in React
- 
----------------------------------------------------------------------------------
- 1:31:26 :> Custom Hook
- 
-- 1:33:37 :> useFetch
  
-- 1:35:40 :> useWindowResize

----------------------------------------------------------------------------------
- 1:37:32 :> React Router Dom
- 
-- 1:38:30 :> Basic Routing
  
-- 1:41:59 :> Link Component

-- 1:43:07 :> Params in route / path

-- 1:45:25 :> Navigate Component

-- 1:46:30 :> Routes

-- 1:47:27 :> Nested Route

-- 1:49:39 :>  " * " (all / any route) mapping aka NotFound 

----------------------------------------------------------------------------------
- 1:50:34 :> useNavigate, navigate via code progmatically
- 
- 1:52:09 :> useCallback
- 
- 1:54:21 :> useMemo
- 
- 1:56:52 :> React.Memo
- 
- 1:58:15 :> Explain the Reconciliation process in React
- 
- 1:59:32 :> PureComponent
- 
- 2:00:40 :> Explain HOC
- 
----------------------------------------------------------------------------------
- 2:02:06 : > Redux
- 
-- 2:03:24 :> Redux : what is action in redux
  
-- 2:04:33 :> Redux : explain reducer in Redux

-- 2:05:26 :> Redux : Role of redux

-- 2:06:41 :> Redux: react-redux > connect ( mapStateToProps, mapDispatchToProps)(Component) > old way to use redux

-- 2:08:30 :> Redux: react-redux > useSelector & useDispatch > latest way to use redux

-- 2:10:07 :> Redux Toolkit 

-- 2:10:43 :> Redux Toolkit > How to configure

-- 2:12:00 :> Redux Toolkit > createSlice ({name:"xxx", initialSlicer:"xxx", reducers:{ ... }})

----------------------------------------------------------------------------------
- 2:13:36 :> Controlled Components
- 
- 2:14:30 :> UnControlled Components
- 
----------------------------------------------------------------------------------
- 2:15:34 :> Optimising performance in React Apps
- 
- 2:16:31 :> Code splitting > lazy() & suspense()
- 
- 2:17:50 :> Render props in React > Example
- 
- 2:18:40 :> Portals in React
- 
- 2:22:05 :> Suspense & Lazy Loading
- 
----------------------------------------------------------------------------------
TypeScript with React

- 2:20:44 :> props in functional component
- 
- 2:21:42 :> useState hook
- 
- 2:22:18 :> specifying type for event handler > https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
- 
- 2:23:19 :> optional props
- 
- 2:24:03 :> useReducer
- 
- 2:25:11 :> ContextAPI
- 
----------------------------------------------------------------------------------
Jest / React Testing Library

- 2:26:10 :> Simple test case
- 
- 2:27:46 :> Rendering component in test case
- 
- 2:28:28 :> Finding element in Jest DOM > screen.{ getByText, getByTestId , getByRole }
- 
- 2:29:53 :> Simulating user event in test case > fireEvent.click / userEvent.click
- 
- 2:31:08 :> Testing props in test case
- 
----------------------------------------------------------------------------------
HANDS ON QUESTIONS :> TRY YOURSELF

- 2:31:53 :> Controlled Input Component
- 
- 2:32:43 :> Toggle Visibility of a component
- 
- 2:32:21 :> Fetch Data from an API & Display in component
- 
- 2:33:53 :> Create a reusable Button Component
- 
- 2:35:05 :> Component that have useEffect with cleanup
- 
- 2:35:47 :> ContextAPI + useReducer + global state management
- 
- 2:36:11 :> Conditional rendering based on props
- 
- 2:27:17 :> Implement a simple form component along with error handling
- 
----------------------------------------------------------------------------------

 - - - - - -         T H A N K   Y O U        - - - - - -
  
  
  ## What is ReactJS?
- React is a **front-end and open-source JavaScript library** which is useful in developing user interfaces specifically for applications with a **single page**. It is helpful in building complex and **reusable user interface(UI) components** of mobile and web applications as it follows the **component-based approach**.

**The important features of React are:**

- It supports **server-side rendering**.
- It will make use of the **virtual DOM rather than real DOM**(Data Object Model) as RealDOM manipulations are expensive.
- It follows **unidirectional data** binding or data flow.
- It uses **reusable or composable UI** components for developing the view.
  
## What are the advantages of using React?

**MVC is generally abbreviated as Model View Controller.**

- **Use of Virtual DOM to improve efficiency:**
- React uses virtual DOM to render the view. As the name suggests, virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves.
 
- **Gentle learning curve:** React has a gentle learning curve when compared to frameworks like Angular. Anyone with little knowledge of javascript can start building web applications using React.

- **SEO friendly:** React allows developers to develop engaging user interfaces that can be easily navigated in various search engines. It also allows server-side rendering, which boosts the SEO of an app.
 
- **Reusable components:** React uses component-based architecture for developing applications. Components are independent and reusable bits of code. These components can be shared across various applications having similar functionality. The re-use of components increases the pace of development.
  
- **Huge ecosystem of libraries to choose from:** React provides you with the freedom to choose the tools, libraries, and architecture for developing an application based on your requirement.
## What is JSX ?
- JSX stands for **JavaScript XML**. It allows us to write HTML inside JavaScript and place them in the DOM without using functions like **appendChild( ) or createElement( ).**
  
 (or)
 
JSX stands for JavaScript XML. **JSX allows us to write HTML in React**. JSX makes it easier to write and add HTML in React.

- in JSX, the curly braces {} are known as "**expression placeholders**". They are used to embed JavaScript expressions inside JSX code. This allows you to insert dynamic content and JavaScript logic directly within the markup.
```javascript

const Example = () => {
  return (
    <>
//JSX
      <h1>Hello</h1>
    </>
  );
};

//expression placeholders
const name = "Alice";
return <h1>Hello, {name}!</h1>

const element = React.createElement(
  'h1', 
  { className: 'greeting' }, 
  'Hello, World!'
);

// Create a new <div> element
const div = document.createElement('div');

// Add some content inside the div
div.textContent = "Hello, World!";

// Append the div to the body of the document
document.body.appendChild(div);

 ```
}
## What is the difference between Element and Component?
**Elements**
      **Definition:** Elements are the **smallest building blocks of React applications**. They are plain objects that describe **what you want to see on the screen.**
     -  You can create elements in React using JSX (which gets converted to React.createElement() calls).
     
      - React elements are not functions; they are simple objects describing the layout and structure of the UI
      
 -    **Creation:** Typically created using **JSX (JavaScript XML) or React.createElement()**.
      
-   **Immutability:** Elements are immutable. Once created, you cannot change their properties or children.
  ```javascript 
            const element = <h1>Hello, React!</h1>;
  ```
**Components**
          **Definition:** Components are **reusable and composable building blocks that return React elements**. They can be thought of as JavaScript functions or classes that take in inputs (called “props”) and return elements.

**Types:** There are two types of components:

**Functional Components:** These are JavaScript functions that return elements.
      ```javascript 
      function Greeting(props) {
        return <h1>Hello, {props.name}!</h1>;
      }
      ```
**Class Components:** These are ES6 classes that extend React.Component and have a render method.
   - **State and Lifecycle:** Components can have state and lifecycle methods, allowing them to manage dynamic data and respond to user interactions.
      ```javascript 
      class Greeting extends React.Component {
        render() {
          return <h1>Hello, {this.props.name}!</h1>;
        }
      }
      ```
## What are the differences between functional and class components ? 

**functional Components**
  -  **Definition:** These are simple JavaScript functions that accept props as an argument and return React elements (JSX).
    
  -  **State and Lifecycle:** Initially, functional components were **stateless**and **did not have lifecycle methods**. However, with 
          the introduction of React Hooks **(e.g., useState, useEffect)**, functional components can now manage state and side effects.
-   **Hooks:** Hooks like **useState and useEffect allow functional components to handle state and lifecycle events**
 ```javascript 
        function Greeting(props) {
      return <h1>Hello, {props.name}!</h1>;
    }
  /////////
  
  import React, { useState, useEffect } from 'react';

      function Counter() {
        const [count, setCount] = useState(0);
      
        useEffect(() => {
          document.title = `You clicked ${count} times`;
        }, [count]);
      
        return (
          <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>Click me</button>
          </div>
        );
      }
 ```
  **Class Components**
    
   - **Definition:** These are ES6 classes that extend from React.Component and have a render method to return React elements.
     
  -   Class components in React are typically **stateful**, meaning they can **manage and maintain their own state**. This is one of the key  features that distinguishes them from stateless functional components .
  -   
**Stateful Components**
  -  **State Management:** Class components can hold and manage local state using **this.state and this.setState**.
  -  **Lifecycle Methods:** They have access to lifecycle methods like **componentDidMount, componentDidUpdate, and 
       componentWillUnmount**, which allow you to run code at specific points in the component’s lifecycle.
        -  **componentDidMount():** Called after the component is mounted.
        - **componentDidUpdate(prevProps, prevState):** Called after the component updates.
        - **componentWillUnmount():** Called before the component is unmounted and destroyed.
```javascript 
import React, { Component } from 'react';

class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  incrementCount = () => {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.incrementCount}>Increment</button>
      </div>
    );
  }
}

export default MyComponent;
```
**Defining a Constructor**
 -  The constructor method is defined within a class and is called automatically when a **new instance of the class is created**.
   
  - **Inside the constructor, the this keyword refers to the new object being created.** It is used to set properties on the object.
    
  - In a derived class (a class that extends another class), you must call **super() before using this in the constructor. This calls the parent class’s constructor.**
 
  - The super keyword is used to call the **constructor of the parent class and to access its methods**.
    
  - When you extend a class, you need to call the parent **class’s constructor using super() before you can use this in the derived class.**
    
  - **Props**
      **Props are passed to class components in the same way as functional components**. They are accessed using **this.props.**
 - The **extends keyword**is a powerful feature in JavaScript that enhances object-oriented programming by allowing classes to inherit from other classes

- **Static Methods and Properties**
        -Static methods and properties are also inherited by the child class.
  
  -**render()**
  - **The render() method**returns the JSX (JavaScript XML) that describes the component’s layout. This JSX is then converted into actual HTML elements in the DOM.
  - The render() method is called whenever there is a **change in the component’s state or props**. This ensures that the UI is always **up-to-date with the latest data.**
  - **The render() method** must return a **single root element**. If you need to return multiple elements, you should wrap them in a **single container element like a <div> or use React fragments**.
  - **No Side Effects** :The render() method should be **pure, meaning it should not modify the component’s state or interact with the browser (e.g., making HTTP requests)**. It should only return the JSX representation of the component
  - React uses a virtual DOM to optimize rendering. **When the render() method is called, React updates the virtual DOM first and then efficiently updates the actual DOM to match the virtual DOM**
    
## What are Pure Components?
  - Pure Components are components that render the same output for the same state and props. **They are designed to optimize performance by preventing unnecessary re-renders. Here are some key points about Pure Components**
    
  - **Definition:** A Pure Component is a **component that does not re-render if the props and state have not changed**.
    This is achieved by implementing a shallow comparison of the current and next props and state.
    
  - **Class-Based Pure Components:** In class-based components, you can create a Pure Component by extending **React.PureComponent** instead of **React.Component**. This automatically implements the **shouldComponentUpdate lifecycle method** with a shallow comparison.
```javascript 
    import React from 'react';

class MyComponent extends React.PureComponent {
    render() {
        return <div>{this.props.value}</div>;
    }
}

import React, { Component } from 'react';
import axios from 'axios';

class DataFetcher extends Component {
  constructor(props) {
    super(props);
    this.state = {
      data: [],
      loading: true,
      error: null,
    };
  }

  componentDidMount() {
    axios.get('https://api.example.com/data')
      .then(response => {
        this.setState({ data: response.data, loading: false });
      })
      .catch(error => {
        this.setState({ error: error.message, loading: false });
      });
  }

  render() {
    const { data, loading, error } = this.state;

    if (loading) {
      return <div>Loading...</div>;
    }

    if (error) {
      return <div>Error: {error}</div>;
    }

    return (
      <div>
        <h1>Data from API</h1>
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}

export default DataFetcher;

```
- **Functional Pure Components:** For functional components, you can achieve similar behavior using **React.memo**. **This higher-order component memoizes the result and only re-renders if the props change**.
```javascript
    import React from 'react';

const MyComponent = React.memo((props) => {
    return <div>{props.value}</div>;
});
```
## What is Pure Functions? and What is imPure Functions?
**Pure Functions**
  - **Deterministic:** Given the **same inputs, a pure function will always return the same output**. This means the function’s output is entirely dependent on its input parameters and nothing else.
 - **No Side Effects:** Pure functions do not cause any side effects. **They do not modify any external state, such as global variables, or perform any I/O operations like logging to the console or making network requests**.
    ```javascript
    function add(a, b) {
        return a + b;
    }
    ```
**imPure Functions**   
 - **Side Effects:** Impure functions cause side effects, meaning they can **modify external state or interact with the outside world**. This **includes changing global variables**, modifying objects or arrays passed by reference, performing I/O operations like logging to the console, or making network requests.

 - **Non-Deterministic:** Impure functions do not always return the same output for the same input. Their output can depend on external factors or the state of the system, making them unpredictable.
```javascript
let counter = 0;

function increment() {
    counter += 1;
    return counter;
}
```
## What is Props? In React, props (short for “properties”) 

  -  **Immutability:** Props are **read-only**. Once a parent component passes props to a child component, the **child component cannot modify them**. This ensures that **data flows in a single direction**, from **parent to child**.
   -  **Usage:** Props are used to **pass data and configuration settings to child components**. They allow components to be **dynamic and reusable by providing different data inputs**.
   - **Accessing Props:** In a functional component, **props are accessed directly as function arguments**. In a **class component, they are accessed via @this.props.**

**how to change props**

  - **props are immutable**, meaning they **cannot be changed directly by the child component**. However, you can achieve the desired **effect by updating the state in the parent component and passing the new state as props to the child component**.
    
 **Using Callbacks to Update Props**
 
  **Define a State in the Parent Component:**
    
     - The parent component holds the state that will be passed as props to the child component.
     
  **Pass a Callback Function to the Child Component:**
  
   -  This callback function will be used by the child component to request changes to the state in the parent component.

**Update the State in the Parent Component:**

   -  When the callback function is called, the parent component updates its state, which in turn updates the props passed to the child component.

**Parent Component**
```javascript
import React, { useState } from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
    const [name, setName] = useState('Alice');

    const handleNameChange = (newName) => {
        setName(newName);
    };

    return (
        <div>
            <h1>Parent Component</h1>
            <ChildComponent name={name} onNameChange={handleNameChange} />
        </div>
    );
}

export default ParentComponent;
```
**Child Component**
```javascript
import React from 'react';

function ChildComponent(props) {
    const changeName = () => {
        props.onNameChange('Bob');
    };

    return (
        <div>
            <h2>Child Component</h2>
            <p>Name: {props.name}</p>
            <button onClick={changeName}>Change Name</button>
        </div>
    );
}

export default ChildComponent;
```
## What Is ‘State’ in ReactJS?
- In ReactJS, state is a built-in object that holds data or information about a component. When the state changes, the component re-renders, meaning it updates its output on the screen

**Purpose**:

- State allows components to dynamically manage and respond to changes in data, such as user input, API responses, or internal calculations.
  
**Data Storage**:
  
- State is a plain JavaScript object that stores component-specific data.
  
**Component Re-rendering**:
  
- When the state of a component changes, React triggers a re-render, ensuring that the UI reflects the updated data.
  
**Updating State**:
  
- The setState() method is used to update the state object. It's important to note that setState() is asynchronous.
  
**Data Flow**:
- State is typically managed within a component, but it can be passed down to child components as props
  

 - **Definition:** State is a built-in object that allows components to create and manage their own data internally.
 - **Mutability:** State is mutable, meaning it can be changed within the component using the setState method (in class components) or 
     the useState hook (in functional components).
 - **Usage:** State is used to manage data that can change over time, typically in response to user actions or other events.

 In ReactJS, state is a built-in object that allows components to create and manage their own data internally. It is a fundamental concept for building dynamic and interactive user interfaces. Here are some key points about state:
 
 - **Dynamic Data Storage:** State is used to store data that can change over time. This data can be anything from user inputs, responses from an API, or any other dynamic data.

 -  **Component-Specific:** Unlike props, which are passed from parent to child components, state is local to the component where it is defined. Each component can have its own state.

 - **Triggers Re-Renders:** When the state of a component changes, React automatically re-renders the component to reflect the new state. This ensures that the UI is always in sync with the state.
```javascript
   import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    const increment = () => {
        setCount(count + 1);
    };

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={increment}>Increment</button>
        </div>
    );
}

export default Counter;
```
## What are inline conditional expressions?

**Ternary Operator**
     - The ternary operator is a concise way to include or exclude elements based on a condition
```javascript
const isLoggedIn = true;

return (
    <div>
        {isLoggedIn ? <p>Welcome back!</p> : <p>Please log in.</p>}
    </div>
);
```
**Logical AND (&&) Operator**
  - The logical AND operator can be used to conditionally render an element only if the condition is true.
 
```javascript
const hasMessages = true;

return (
    <div>
        {hasMessages && <p>You have new messages.</p>}
    </div>
);
```
 **Inline If-Else with IIFE (Immediately Invoked Function Expression)**
     - For more complex conditions, you can use an IIFE to handle inline if-else logic.
```javascript

const userRole = 'admin';

return (
    <div>
        {(() => {
            if (userRole === 'admin') {
                return <p>Admin Dashboard</p>;
            } else if (userRole === 'user') {
                return <p>User Dashboard</p>;
            } else {
                return <p>Guest Dashboard</p>;
            }
        })()}
    </div>
);
```
## What is Prop Drilling? 
 -  Prop drilling occurs when you need to **pass a prop through several layers of nested components to reach a deeply nested child component** that actually needs the prop. Each intermediary component in the hierarchy has to pass the prop down, even if it doesn’t use the prop itself.
 -  **Prop drilling in react is the process of passing data from one component via several interconnected components to the component that needs it**.
 -  The name drilling refers to this process of forcing these components to take in **unnecessary data and pass it on to the following component**, which in **turn sends it on to the next component**, and so on until it reaches its intended destination. The reusability of components and app performance may suffer as a result in a significant way.
![image](https://github.com/user-attachments/assets/1d097f86-d1ea-46d3-949b-822d4e7704c3)

# ReactJS Lifecycle of Components ?
![image](https://github.com/user-attachments/assets/63c38d8f-a446-4299-bec4-16665515c9ed)

**Initialization**: This is the stage where the component is constructed with the given Props and default state. This is done in the **constructor of a Component Class**.

**Mounting**: The component is ready to mount in the browser DOM. 
 - This phase covers **initialization from constructor(), getDerivedStateFromProps(), render(), and componentDidMount()** lifecycle methods.

**Updating**: In this phase, the component gets updated in two ways, **sending the new props and updating the state either from setState() or forceUpdate(). This phase covers getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate()** and componentDidUpdate() lifecycle methods.

**Unmounting**: In this last phase, the component is not needed and gets unmounted from the browser DOM. This phase includes **componentWillUnmount() lifecycle method**.  All the cleanups such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount() should be coded in the componentWillUnmount() method block.

- **Initialization**: In this phase, the developer has to define the props and initial state of the component this is generally done in the constructor of the component. The following code snippet describes the initialization process.
```javascript
    class Clock extends React.Component { 
    constructor(props) { 
        // Calling the constructor of Parent Class React.Component 
        super(props); 
        
        // Setting the initial state 
        this.state = { date: new Date() }; 
    } 
}

```
**Lifecycle Methods in Initialization**

  - **constructor():** Initializes the component’s state and binds methods.

 - **getDerivedStateFromProps():** Can be used to update the state based on initial props, though it’s less commonly used in the initialization phase.

 - **class Clock extends React.Component:** This defines a new class **Clock** that **extends** **React.Component,** making it a React component.

 - **constructor(props):** The constructor method is called when an instance of the **class is created**.

 - **super(props):** This calls the constructor of the **parent class** (React.Component), allowing the component to access **this.props**.

 - **this.state = { date: new Date() }:** This sets the **initial state of the component** with the current date.
 - 
 - **render():** The only required method in a class component. It returns the JSX that **represents the component’s UI**.
   
**Mounting**

  **componentWillMount() Function:** As the name clearly suggests, this function is invoked right before the component is mounted on the DOM i.e.**this function gets invoked once before the render() function is executed for the first time**.
  
 - The componentWillMount() lifecycle hook is primarily used to implement server-side logic before the actual rendering happens, such as making an API call to the server.
 
 - The componentWillMount() method allows us to **execute the React code synchronously** when the component **gets loaded or mounted in the DOM** (Document Object Model). This method is called during the mounting phase of the React Life-cycle.

- **ComponentWillMount()** is generally used to **show a loader when the component is being loaded or when the data from the server is being fetched**.
  
 **componentDidMount() Function:** Similarly to the previous one this function is invoked right after the component is mounted on the DOM i.e.**this function gets invoked once after the render() function is executed for the first time**
 
   -   The componentDidMount() method is used to **fetch data from an API**.
     
   -   The fetched data is then stored in the **component’s state, triggering a re-render to display the data**.

**Updation**

- **setState() Function:** This is not particularly a Lifecycle function and can be invoked explicitly at any instant. This function is used to update the state of a component. 

**shouldComponentUpdate() Function:** By default, every state or props update re-renders the page but this may not always be the desired outcome, sometimes it is desired that updating the page will not be repainted. 
- The shouldComponentUpdate() Function fulfills the requirement by letting React know whether the component’s output will be affected by the update or not. shouldComponentUpdate() is invoked before rendering an already mounted component when new props or states are being received.

-  If returned false then the subsequent steps of rendering will not be carried out. This function can’t be used in the case of **forceUpdate().** The Function takes the new Props and new State as the arguments and returns whether to re-render or not.

**componentWillUpdate() Function:** As the name clearly suggests, this function is invoked before the component is rerendered i.e. this function gets invoked once before the render() function is executed after the updation of State or Props.

**componentDidUpdate() Function:** Similarly this function is invoked after the component is rerendered i.e. this function gets invoked once after the render() function is executed after the updation of State or Props.

 **Unmounting:**  : **This phase occurs when a component is being removed from the DOM**.

  - **componentWillUnmount():** Called right before the component is **unmounted and destroyed**. It’s a good place to clean up subscriptions or cancel network requests.
    
   -  This is the final phase of the lifecycle of the component which is the phase of unmounting the component from the DOM. The following function is the sole member of this phase.

**componentWillUnmount() Function:** This function is invoked before the component is finally unmounted from the DOM i.e. this function gets invoked once before the component is removed from the page and this denotes the end of the lifecycle.

**what is Higher-Order Components (HOCs) ?**
      - An HOC is a **function that takes a component and returns a new component with additional functionality**.
- Higher-Order Components (HOCs) in React are functions that take a component and return a new component with additional features or functionality. This “wrapping” allows you to enhance the original component by **adding extra props, state, or behavior.**
- 
**Benefits of Using HOCs with Functional Components**

  - **Code Reusability:** HOCs allow you to reuse logic across multiple components, reducing code duplication.

  - **Separation of Concerns:** They help separate different concerns, making your components more focused and easier to maintain.

  - **Enhanced Composition:** HOCs can be composed together to build complex functionality from simple, reusable pieces
 
 ##  What are stateless and stateful  components?
 components can be classified into two main types: **stateless (or functional) components and stateful (or class) components**. Let’s explore the differences between them:

**Stateless Components**
 - **Definition**: Stateless components, also known as functional components, do not manage their own state. They simply receive data via props and render UI elements based on that data.

**Characteristics:**

 - **No State Management:** They do not have their own state.
   
 - **Simpler and More Readable:** They are usually simpler and easier to read and maintain.
   
 - **No Lifecycle Methods**: They do not have lifecycle methods like class components, but with the introduction of Hooks usestate ,useeffect, they can now use state and other React features.

**Stateful Components**
  -   **Definition**: Stateful components, traditionally class components, manage their own state. They keep track of changing data that affects the render output of the component.

**Characteristics:**

 - **State Management:** They have a state object that stores data and can update this state.
   
 - **Lifecycle Methods:** They have lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount.
   
 - **More Complex:** They are usually more complex than stateless components due to state management and lifecycle methods.
```javascript

   class Counter extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }

    increment = () => {
        this.setState({ count: this.state.count + 1 });
    };

    render() {
        return (
            <div>
                <p>Count: {this.state.count}</p>
                <button onClick={this.increment}>Increment</button>
            </div>
        );
    }
}
```
## What is the purpose of render() in React. ?
**Purpose of render() in React**

  - **Returning JSX:** The primary purpose of the **render() method is to return JSX**, which **describes the structure of the component’s UI**. This JSX is then transformed into **actual HTML elements by React**.

  - **Updating the Virtual DOM:** The render() method updates the virtual DOM, which is a lightweight copy of the actual DOM. React uses this virtual DOM to determine what changes need to be made to the actual DOM, ensuring efficient updates.

     - When the state or props of a component change, the render() method is called to update the virtual DOM with the new UI structure1.
     - 
**Reactivity:** The render() method is called whenever there is a change in the component’s state or props. This ensures that the UI is always in sync with the current state and props
**Functional Components and render()**
  -  In functional components, **there is no explicit render() method**. Instead, the function itself **returns the JSX**, which serves the same purpose as the render() method in class components.
     
```javascript
class Counter extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }

    increment = () => {
        this.setState({ count: this.state.count + 1 });
    };

    render() {
        return (
            <div>
                <p>Count: {this.state.count}</p>
                <button onClick={this.increment}>Increment</button>
            </div>
        );
    }
}
```
## What is the useState Hook?

   - The useState() hook works by **handling and managing state** in your applications.
 
  -  **UseState** is React Hook that allows you to **add state to a functional component**.

  -  It returns an array with two values: the **current state** and a **function to update it**.
    
  - The Hook takes an initial state value as an argument and returns an updated state value whenever the setter function is called. It can be used like this:
          ```javascript
             const [state, setState] = useState(initialValue);
          ```
    
   ![image](https://github.com/user-attachments/assets/c43e83c4-bc4e-4535-aa8f-c084c6973523)
   

  - Here, the initialValue is the value you want to start with, and state is the current state value that can be used in your component. The setState function can be used 
    to **update the state, triggering a re-render of your component**.
    
 -   In React, **each component can maintain its own state, and when this state changes, the component re-renders to reflect the updated data in the user interface**. This 
       is a core concept in React that makes it powerful for building dynamic and interactive UIs.

**How It Works**

-   **Component State:** Each React component can have its own state, which is managed using hooks like useState or useReducer.
  
-   **State Update:** When the state is updated using the state updater function (e.g., setState from useState), React schedules a re-render of the component.
  
-   **Re-rendering:** During the re-render, React compares the new state with the previous state and updates the DOM to reflect any changes. This process is called reconciliation.
 ```javascript
import React, { useState } from 'react';

function SignIn() {
  const [isSignedIn, setIsSignedIn] = useState(false);

  const handleSignIn = () => setIsSignedIn(true);
  const handleSignOut = () => setIsSignedIn(false);

  return (
    <div>
      {isSignedIn ? (
        <div>
          <button onClick={handleSignOut}>Sign Out</button>
          <p>Welcome back!</p>
        </div>
      ) : (
        <div>
          <button onClick={handleSignIn}>Sign In</button>
          <p>Please sign in</p>
        </div>
      )}
    </div>
  );
}

export default SignIn;
```
 ```javascript
import React, { useState } from 'react';

function Counter() {
  // Declare a state variable named "count" with an initial value of 0
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Counter;
```
## what is useEffect() ?
**What are side effects in React?**
    - Side effects are **not predictable** because they are actions which are performed with the "**outside world.**"
    
   - We perform a side effect when we need to reach outside of our React components to do something. **Performing a side effect**,
     however, will not give us a predictable result.

  - Think about if we were to request data (like blog posts) from a server that has failed and instead of our post data, gives us a 500 status code response.
    
   - Virtually all applications rely on side effects to work in one way or another, aside from the simplest applications.

**Common side effects include:**

   -   Making a request to an **API for data from a backend server**
     
   -   To **interact with browser APIs** (that is, to use document or window directly
     
   -   Using unpredictable timing functions like **setTimeout or setInterval**
     
**useEffect() arguments**

- useEffect() hook accepts 2 arguments
  
 ```javascript
     useEffect(callback[, dependencies])
 ``` 
- callback is a function that contains the **side-effect logic**. callback is **executed right after the DOM update**.
  
- dependencies is an optional **array of dependencies**. useEffect() executes callback only if the **dependencies have changed between renderings**.
  
- Put your side-effect logic into the callback function, then use the dependencies argument to control when you want the side-effect to run. That's the sole purpose of useEffect().
  
 ```javascript  
  useEffect(() => {
  document.title = `Greetings to ${name}`;
}, [name]);
```
**Dependencies argument**

    - Dependencies argument of useEffect(callback, dependencies) lets you control when the side-effect runs.
    
   **A) Not provided:** the side-effect runs **after every rendering**.  
```javascript 
 import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Runs after EVERY rendering
  });  
}
```
**B) An empty array []:** the side-effect runs **once after the initial rendering**.
```javascript 
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Runs ONCE after initial rendering
  }, []);
}
```
**C) Has props or state values [prop1, prop2, ..., state1, state2]:** the side-effect runs **once after initial rendering and then only when any dependency value changes**.
```javascript 
import { useEffect, useState } from 'react';

function MyComponent({ prop }) {
  const [state, setState] = useState('');
  useEffect(() => {
    // Runs ONCE after initial rendering
    // and after every rendering ONLY IF `prop` or `state` changes
  }, [prop, state]);
}
```
![image](https://github.com/user-attachments/assets/7f2600d7-b134-496a-b27e-32872e638975)

**Component lifecycle**

 - The dependencies argument of the useEffect() lets you catch certain component lifecycle events: when the component has been mounted or a **specific prop or state value has changed**.
        
  **Component did mount**
  
 - Use an empty dependencies array to **invoke a side-effect once after component mounting**
      
 **Component did update**
 
  - Each time the **side-effect uses props or state values, you must indicate these values as dependencies**:
    
 -   useEffect(callback, [prop, state]) invokes the callback once after mounting, and again after committing the changes to the DOM, if and only if any value in the dependencies array [prop, state] has changed.
    
**Side-effect cleanup**

 - Some side-effects need cleanup: close a socket, clear timers.

  If the callback of useEffect(callback, deps) returns a function, then useEffect() considers that function as an effect cleanup

**Cleanup works the following way:**

A) After initial rendering, useEffect() invokes the callback with the side-effect. cleanup function is not invoked.

B) On later renderings, before invoking the next side-effect callback, useEffect() invokes the cleanup function from the previous side-effect execution (to clean up everything after the previous side-effect), then invokes the current side-effect.

C) Finally, after unmounting the component, useEffect() invokes the cleanup function from the latest side-effect.

**Fetching data**
```javascript 
import { useEffect, useState } from 'react';

function FetchEmployees() {
  const [employees, setEmployees] = useState([]);

  useEffect(() => {
    async function fetchEmployees() {
      const response = await fetch('/employees');
      const fetchedEmployees = await response.json();
      setEmployees(fetchedEmployees);
    }

    fetchEmployees();
  }, []);

  return (
    <div>
      {employees.map(name => <div>{name}</div>)}
    </div>
  );
}
```
## Use React useReducer() Hook ?

 - useReducer hook in React is used to **store and update states**, particularly in situations where the state management logic is **complex or involves multiple related values**
 - The useReducer() hook in React is used to manage complex state changes in a React application: 
    
 - The useReducer(**reducer, initialState**) hook accepts **2 arguments**: the **reducer function** and the **initial state**. The hook then **returns an array of 2 items**: the **current state** and the **dispatch function**.

```javascript 
      const [state, dispatch] = useReducer(reducer, initialState)
```
 ![image](https://github.com/user-attachments/assets/acc967fa-b4f1-461f-9bf9-d8e6587e16d4)
 
-  The reducer is a pure function that **accepts 2 parameters**: the **current state** and an **action object**. Depending on the action object, the reducer function must update the state in an immutable manner, and return the new state.
  
- The reducer function itself accepts two parameters and returns one value. The first parameter is the current state, and the second is the action. The state is the data we are manipulating. The reducer function receives an action, which is executed by a dispatch function
  
**Initial state**

- The initial state is the value the state is initialized with.
  
**Action object**

- An action object is an object that describes how to update the state.

 **The dispatch method**
 
  - The dispatch **function accepts an object that represents the type of action we want to execute when it is called**. Basically, it sends the type of **action to the reducer function to perform 
        its job, which, of course, is updating the state**.
    
    -  The action to be executed is specified in our reducer function, which in turn, is passed to the useReducer. **The reducer function will then return the updated state**.
    
    -  The actions that will be dispatched by our components should always be represented as one object with the **type and payload key**, where **type** stands as the **identifier of the 
       dispatched action**  and **payload** is the **piece of information that this action will add to the state**.
```javascript 
import React, { useReducer } from 'react';

// Initial state
const initialState = { count: 0 };

// Reducer function
const reducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>
    </div>
  );
};

export default Counter;
```
**Custom hooks**

- Custom hooks in React are reusable functions that encapsulate stateful logic, allowing you to share code between components without changing the component hierarchy. 
    
- They are built on top of existing hooks (like useState, useEffect, etc.) and can help you abstract and organize your logic more effectively.

**Why should we use custom hooks?**
     **The main reasons to use customs hooks are:**

- It helps you to separate your logic from the user interface
      
- It allows you to create re-usable logic blocks
      
- It makes your component more understandable
      
- It increases the modularity of your code
  
**When should we use custom hooks?**

-  When you are using the same logic in different components
      
-  When your logic is very complex
      
-  When you are working on a large-scale project
  
## useCallback vs useMemo ?

 **useCallback**
 
   - **Purpose**: useCallback is used to **memoize functions**. It returns a **memoized version of the callback function** that **only changes if one of the dependencies has changed**.
 
   - **When to Use:** Use useCallback when you want to avoid **re-creating a function on every render**, particularly if that function is passed as a prop to a child component that relies on reference equality to prevent unnecessary renders.
```javascript 
 import React, { useState, useCallback } from 'react';

const Counter = ({ onIncrement }) => {
  console.log('Counter rendered');
  return <button onClick={onIncrement}>Increment</button>;
};

const App = () => {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []);

  return (
    <div>
      <h1>Count: {count}</h1>
      <Counter onIncrement={increment} />
    </div>
  );
};
````
## useMemo

- **Purpose:** useMemo is used to **memoize the result of a computation (like a value or an object)**. It returns a memoized value that only **recalculates if one of the dependencies has changed**.

- **When to Use:** Use useMemo when you want to **optimize expensive calculations that don’t need to run on every render**.
```javascript 
import React, { useState, useMemo } from 'react';

const App = () => {
  const [count, setCount] = useState(0);

  const squared = useMemo(() => {
    console.log('Calculating square...');
    return count * count;
  }, [count]);

  return (
    <div>
      <h1>Count: {count}</h1>
      <h2>Squared: {squared}</h2>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

**Type of Value:**

  - useCallback **memoizes a function**.

  - useMemo **memoizes a computed value**.
    
**Use Cases:**

  - Use useCallback to **prevent re-creating functions** that are passed as props to child components.
 
  - Use useMemo to **optimize expensive calculations** or to **memoize values** that depend on other state or props.
  - 
**Return Value:**

  - useCallback(fn, deps) returns the **memoized version of fn**.
  
  - useMemo(() => value, deps) returns the **memoized value**.
    
**Summary**

- Use useCallback to **memoize functions** to prevent **unnecessary re-creations**.

- Use useMemo to **memoize values** to avoid expensive **calculations on every render**.

Both hooks help improve performance in functional components, especially in larger applications.

# What is Redux?

  - The main feature of Redux is to **manage and update the state of an application**.
    
 ![image](https://github.com/user-attachments/assets/5ea67496-1530-4833-8304-b4b0d374c9ff)

 **useSelector** and **useDispatch** in React Components
 
**What is useSelector?**
- The useSelector hooks allow you to **extract data or the state from the Redux store using a selector function**. 

- when an **action is performed**, the **useSelector() hook will compare the results of the previous and current selector values and if they are different then the component is bound to re-render otherwise it stays the same**.

- The function will be called with the entire redux store state as an argument and runs whenever the functional components render the page. The useSelector() hook will subscribe to the redux store and runs whenever an action is dispatched.

**useSelector**
 - I mentioned before that if you want to get the state you will use a selector. This is how you can access the redux state.

**useDispatch**
 - Lastly, if we want to modify the global state we need to useDispatch and the action that we already created in slice.

## React Context ?

  - React Context is a built-in feature of React that allows you to **share values across the component tree without having to pass props down manually at every level**.
    
 -  It provides a way to **create global data that can be accessed by any component in the tree**, which helps **avoid "prop drilling**" (passing props through many layers of components).

 -  Context API eliminates the problem of prop drilling by creating a global context. The key components are Provider, Consumer, and Context.

**When to Use React Context**

**Simple State Management:**

 - If your application has a **relatively simple state or only needs to pass data down through a few levels of components**, React Context can be an elegant solution without the overhead of Redux.

**Avoiding Prop Drilling:**

- Context is great for avoiding "**prop drilling**," where you have to pass props through many layers of components just to get data to a deeply nested component.
  
**Local State:**

- If you only need to manage local state that doesn’t require complex actions or side effects, Context is a good fit. It’s built into React, making it easy to use without additional libraries.

**Theming and Global Settings:**

- Context is often used for global settings like themes, localization, or user authentication, where data needs to be accessible throughout the application.
  
**When to Use Redux**

**Complex State Management:**

- Redux is more suitable for applications with complex **state management needs**, where multiple components may need to read or modify the same state.
  
**Predictable State Changes:**

- Redux provides a clear structure for **managing state changes through actions and reducers**, making it easier to trace **how state changes over time**.
 
**Middleware for Side Effects:**

- If your application involves **complex side effects (like API calls, data fetching, etc.)**, Redux's middleware **(like Redux Thunk or Redux Saga)** offers a powerful way to handle those.
  
**Developer Tools:**

- Redux has excellent developer tools that allow for time-travel debugging, logging actions, and inspecting state changes, which can be very helpful during development.
- 
**Summary**
  
- **React Context:** Best for simple state management, avoiding prop drilling, and sharing global data/settings across components.
  
- **Redux:** Ideal for complex state management needs, predictable state changes, handling side effects, and needing robust developer tools.
```javascript 
import React, { createContext, useState } from 'react'
 //step=1
const Authcontect = createContext()

//step=2 {children} 

export const Postcontext = ({children}) => {
    
    const [data ,setData]=useState(
         [
            { name: 'John', age: 25, height: 175 },
            { name: 'Mary', age: 30, height: 165 },
            { name: 'Bob', age: 40, height: 180 },
            { name: 'Jane', age: 20, height: 170 }
          ]

    )
//step=3
  return (
        <Authcontect.Provider value={data}>
            {children}
        </Authcontect.Provider>
  )
}
//step=4
export default Authcontect

//////
 import React, { useContext } from 'react'
import Postcontext from './Postcontext'

const Context = () => {
    const data = useContext(Postcontext)
    console.log(data)
  return (
    <div>
{
    data.map((e)=>{
        const {name}=e
        return (
            <div> {name} </div>
        )
    })
}
    </div>
  )
}

export default Context
```
  
**usememo**

- When we say "expensive calculations" in the context of React (or any programming environment), we refer to operations or computations that require significant processing time or resources. These could be operations like complex mathematical calculations, filtering large datasets, sorting, or rendering large components with many elements.

- "Recalculating the value on every render" means that each time the component re-renders (due to state or prop changes), the computation is run again, even if the data or conditions that triggered it haven’t changed. This can lead to performance issues, especially if the calculation is complex or the component re-renders frequently.

- Why is it a problem?
  
- In React, a component re-renders whenever its state or props change. If your component involves an expensive calculation, this calculation might get triggered on every re-render, which can result in:

- Slow performance: The app can become sluggish if the expensive computation happens frequently.
Unnecessary computations: In many cases, the result of the computation does not change between renders (for example, the data you’re working with is the same), so re-running the calculation wastes resources.

 imp  https://chatgpt.com/share/6739f810-d3e4-800c-b263-4cf140296db1


- **useCallback() Explained**
- 
- In React, useCallback() is a hook used to memoize functions, meaning it prevents the function from being recreated on every render unless one of its dependencies changes. This can be helpful in optimizing performance, especially when passing functions down to child components or using functions inside hooks like useEffect(), where recreating the function on every render may cause unnecessary re-renders of child components or effects.

  **Why is useCallback() Useful?**
  
- When a component re-renders, all functions inside it are re-created. This includes both event handlers and other functions that may be passed to child components or used in useEffect() dependencies. This might not be an issue for small apps, but in complex or large apps, frequent re-creations of functions can lead to performance problems, especially when passing functions as props to child components, leading to unnecessary re-renders.

- By memoizing a function, useCallback() ensures that the function reference stays the same between renders unless the specified dependencies change. This is particularly useful for:

-**Passing callbacks to child components:** If a child component re-renders due to its parent’s state change, using useCallback() can prevent re-renders of the child component caused by the function reference changing.
Using functions in useEffect() dependencies: Recreating functions on each render can cause unnecessary re-renders or re-executions of effects.
